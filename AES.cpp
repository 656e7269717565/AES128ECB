//a na√Øve AES-128 ECB
#include <iostream>
#include <array>
#include <vector>

using std::cout;
using std::cin;
using std::array;
using Byte=std::uint8_t;//name type is a bit long so I changed it, and yes, technically speaking uint8_t and byte are not the same in c++ but idc.
using std::vector;

const Byte sBox[256] = {
0x63,0x7c,0x77,0x7b,0xf2,0x6b,0x6f,0xc5,0x30,0x01,0x67,0x2b,0xfe,0xd7,0xab,0x76,
0xca,0x82,0xc9,0x7d,0xfa,0x59,0x47,0xf0,0xad,0xd4,0xa2,0xaf,0x9c,0xa4,0x72,0xc0,
0xb7,0xfd,0x93,0x26,0x36,0x3f,0xf7,0xcc,0x34,0xa5,0xe5,0xf1,0x71,0xd8,0x31,0x15,
0x04,0xc7,0x23,0xc3,0x18,0x96,0x05,0x9a,0x07,0x12,0x80,0xe2,0xeb,0x27,0xb2,0x75,
0x09,0x83,0x2c,0x1a,0x1b,0x6e,0x5a,0xa0,0x52,0x3b,0xd6,0xb3,0x29,0xe3,0x2f,0x84,
0x53,0xd1,0x00,0xed,0x20,0xfc,0xb1,0x5b,0x6a,0xcb,0xbe,0x39,0x4a,0x4c,0x58,0xcf,
0xd0,0xef,0xaa,0xfb,0x43,0x4d,0x33,0x85,0x45,0xf9,0x02,0x7f,0x50,0x3c,0x9f,0xa8,
0x51,0xa3,0x40,0x8f,0x92,0x9d,0x38,0xf5,0xbc,0xb6,0xda,0x21,0x10,0xff,0xf3,0xd2,
0xcd,0x0c,0x13,0xec,0x5f,0x97,0x44,0x17,0xc4,0xa7,0x7e,0x3d,0x64,0x5d,0x19,0x73,
0x60,0x81,0x4f,0xdc,0x22,0x2a,0x90,0x88,0x46,0xee,0xb8,0x14,0xde,0x5e,0x0b,0xdb,
0xe0,0x32,0x3a,0x0a,0x49,0x06,0x24,0x5c,0xc2,0xd3,0xac,0x62,0x91,0x95,0xe4,0x79,
0xe7,0xc8,0x37,0x6d,0x8d,0xd5,0x4e,0xa9,0x6c,0x56,0xf4,0xea,0x65,0x7a,0xae,0x08,
0xba,0x78,0x25,0x2e,0x1c,0xa6,0xb4,0xc6,0xe8,0xdd,0x74,0x1f,0x4b,0xbd,0x8b,0x8a,
0x70,0x3e,0xb5,0x66,0x48,0x03,0xf6,0x0e,0x61,0x35,0x57,0xb9,0x86,0xc1,0x1d,0x9e,
0xe1,0xf8,0x98,0x11,0x69,0xd9,0x8e,0x94,0x9b,0x1e,0x87,0xe9,0xce,0x55,0x28,0xdf,
0x8c,0xa1,0x89,0x0d,0xbf,0xe6,0x42,0x68,0x41,0x99,0x2d,0x0f,0xb0,0x54,0xbb,0x16};

const Byte InvSbox[256] = {
0x52,0x09,0x6a,0xd5,0x30,0x36,0xa5,0x38,0xbf,0x40,0xa3,0x9e,0x81,0xf3,0xd7,0xfb,
0x7c,0xe3,0x39,0x82,0x9b,0x2f,0xff,0x87,0x34,0x8e,0x43,0x44,0xc4,0xde,0xe9,0xcb,
0x54,0x7b,0x94,0x32,0xa6,0xc2,0x23,0x3d,0xee,0x4c,0x95,0x0b,0x42,0xfa,0xc3,0x4e,
0x08,0x2e,0xa1,0x66,0x28,0xd9,0x24,0xb2,0x76,0x5b,0xa2,0x49,0x6d,0x8b,0xd1,0x25,
0x72,0xf8,0xf6,0x64,0x86,0x68,0x98,0x16,0xd4,0xa4,0x5c,0xcc,0x5d,0x65,0xb6,0x92,
0x6c,0x70,0x48,0x50,0xfd,0xed,0xb9,0xda,0x5e,0x15,0x46,0x57,0xa7,0x8d,0x9d,0x84,
0x90,0xd8,0xab,0x00,0x8c,0xbc,0xd3,0x0a,0xf7,0xe4,0x58,0x05,0xb8,0xb3,0x45,0x06,
0xd0,0x2c,0x1e,0x8f,0xca,0x3f,0x0f,0x02,0xc1,0xaf,0xbd,0x03,0x01,0x13,0x8a,0x6b,
0x3a,0x91,0x11,0x41,0x4f,0x67,0xdc,0xea,0x97,0xf2,0xcf,0xce,0xf0,0xb4,0xe6,0x73,
0x96,0xac,0x74,0x22,0xe7,0xad,0x35,0x85,0xe2,0xf9,0x37,0xe8,0x1c,0x75,0xdf,0x6e,
0x47,0xf1,0x1a,0x71,0x1d,0x29,0xc5,0x89,0x6f,0xb7,0x62,0x0e,0xaa,0x18,0xbe,0x1b,
0xfc,0x56,0x3e,0x4b,0xc6,0xd2,0x79,0x20,0x9a,0xdb,0xc0,0xfe,0x78,0xcd,0x5a,0xf4,
0x1f,0xdd,0xa8,0x33,0x88,0x07,0xc7,0x31,0xb1,0x12,0x10,0x59,0x27,0x80,0xec,0x5f,
0x60,0x51,0x7f,0xa9,0x19,0xb5,0x4a,0x0d,0x2d,0xe5,0x7a,0x9f,0x93,0xc9,0x9c,0xef,
0xa0,0xe0,0x3b,0x4d,0xae,0x2a,0xf5,0xb0,0xc8,0xeb,0xbb,0x3c,0x83,0x53,0x99,0x61,
0x17,0x2b,0x04,0x7e,0xba,0x77,0xd6,0x26,0xe1,0x69,0x14,0x63,0x55,0x21,0x0c,0x7d};

const Byte Mul2[256] = { //you can code the actual math for the multiplication or have time complexity O[1], I choose the latter ;)
0x00,0x02,0x04,0x06,0x08,0x0a,0x0c,0x0e,0x10,0x12,0x14,0x16,0x18,0x1a,0x1c,0x1e,
0x20,0x22,0x24,0x26,0x28,0x2a,0x2c,0x2e,0x30,0x32,0x34,0x36,0x38,0x3a,0x3c,0x3e,
0x40,0x42,0x44,0x46,0x48,0x4a,0x4c,0x4e,0x50,0x52,0x54,0x56,0x58,0x5a,0x5c,0x5e,
0x60,0x62,0x64,0x66,0x68,0x6a,0x6c,0x6e,0x70,0x72,0x74,0x76,0x78,0x7a,0x7c,0x7e,	
0x80,0x82,0x84,0x86,0x88,0x8a,0x8c,0x8e,0x90,0x92,0x94,0x96,0x98,0x9a,0x9c,0x9e,
0xa0,0xa2,0xa4,0xa6,0xa8,0xaa,0xac,0xae,0xb0,0xb2,0xb4,0xb6,0xb8,0xba,0xbc,0xbe,
0xc0,0xc2,0xc4,0xc6,0xc8,0xca,0xcc,0xce,0xd0,0xd2,0xd4,0xd6,0xd8,0xda,0xdc,0xde,
0xe0,0xe2,0xe4,0xe6,0xe8,0xea,0xec,0xee,0xf0,0xf2,0xf4,0xf6,0xf8,0xfa,0xfc,0xfe,
0x1b,0x19,0x1f,0x1d,0x13,0x11,0x17,0x15,0x0b,0x09,0x0f,0x0d,0x03,0x01,0x07,0x05,
0x3b,0x39,0x3f,0x3d,0x33,0x31,0x37,0x35,0x2b,0x29,0x2f,0x2d,0x23,0x21,0x27,0x25,
0x5b,0x59,0x5f,0x5d,0x53,0x51,0x57,0x55,0x4b,0x49,0x4f,0x4d,0x43,0x41,0x47,0x45,
0x7b,0x79,0x7f,0x7d,0x73,0x71,0x77,0x75,0x6b,0x69,0x6f,0x6d,0x63,0x61,0x67,0x65,
0x9b,0x99,0x9f,0x9d,0x93,0x91,0x97,0x95,0x8b,0x89,0x8f,0x8d,0x83,0x81,0x87,0x85,
0xbb,0xb9,0xbf,0xbd,0xb3,0xb1,0xb7,0xb5,0xab,0xa9,0xaf,0xad,0xa3,0xa1,0xa7,0xa5,
0xdb,0xd9,0xdf,0xdd,0xd3,0xd1,0xd7,0xd5,0xcb,0xc9,0xcf,0xcd,0xc3,0xc1,0xc7,0xc5,
0xfb,0xf9,0xff,0xfd,0xf3,0xf1,0xf7,0xf5,0xeb,0xe9,0xef,0xed,0xe3,0xe1,0xe7,0xe5};

const Byte Mul3[256] = {
0x00,0x03,0x06,0x05,0x0c,0x0f,0x0a,0x09,0x18,0x1b,0x1e,0x1d,0x14,0x17,0x12,0x11,
0x30,0x33,0x36,0x35,0x3c,0x3f,0x3a,0x39,0x28,0x2b,0x2e,0x2d,0x24,0x27,0x22,0x21,
0x60,0x63,0x66,0x65,0x6c,0x6f,0x6a,0x69,0x78,0x7b,0x7e,0x7d,0x74,0x77,0x72,0x71,
0x50,0x53,0x56,0x55,0x5c,0x5f,0x5a,0x59,0x48,0x4b,0x4e,0x4d,0x44,0x47,0x42,0x41,
0xc0,0xc3,0xc6,0xc5,0xcc,0xcf,0xca,0xc9,0xd8,0xdb,0xde,0xdd,0xd4,0xd7,0xd2,0xd1,
0xf0,0xf3,0xf6,0xf5,0xfc,0xff,0xfa,0xf9,0xe8,0xeb,0xee,0xed,0xe4,0xe7,0xe2,0xe1,
0xa0,0xa3,0xa6,0xa5,0xac,0xaf,0xaa,0xa9,0xb8,0xbb,0xbe,0xbd,0xb4,0xb7,0xb2,0xb1,
0x90,0x93,0x96,0x95,0x9c,0x9f,0x9a,0x99,0x88,0x8b,0x8e,0x8d,0x84,0x87,0x82,0x81,	
0x9b,0x98,0x9d,0x9e,0x97,0x94,0x91,0x92,0x83,0x80,0x85,0x86,0x8f,0x8c,0x89,0x8a,
0xab,0xa8,0xad,0xae,0xa7,0xa4,0xa1,0xa2,0xb3,0xb0,0xb5,0xb6,0xbf,0xbc,0xb9,0xba,
0xfb,0xf8,0xfd,0xfe,0xf7,0xf4,0xf1,0xf2,0xe3,0xe0,0xe5,0xe6,0xef,0xec,0xe9,0xea,	
0xcb,0xc8,0xcd,0xce,0xc7,0xc4,0xc1,0xc2,0xd3,0xd0,0xd5,0xd6,0xdf,0xdc,0xd9,0xda,	
0x5b,0x58,0x5d,0x5e,0x57,0x54,0x51,0x52,0x43,0x40,0x45,0x46,0x4f,0x4c,0x49,0x4a,
0x6b,0x68,0x6d,0x6e,0x67,0x64,0x61,0x62,0x73,0x70,0x75,0x76,0x7f,0x7c,0x79,0x7a,	
0x3b,0x38,0x3d,0x3e,0x37,0x34,0x31,0x32,0x23,0x20,0x25,0x26,0x2f,0x2c,0x29,0x2a,
0x0b,0x08,0x0d,0x0e,0x07,0x04,0x01,0x02,0x13,0x10,0x15,0x16,0x1f,0x1c,0x19,0x1a};

const Byte Mul9[256] = {
0x00,0x09,0x12,0x1b,0x24,0x2d,0x36,0x3f,0x48,0x41,0x5a,0x53,0x6c,0x65,0x7e,0x77,
0x90,0x99,0x82,0x8b,0xb4,0xbd,0xa6,0xaf,0xd8,0xd1,0xca,0xc3,0xfc,0xf5,0xee,0xe7,
0x3b,0x32,0x29,0x20,0x1f,0x16,0x0d,0x04,0x73,0x7a,0x61,0x68,0x57,0x5e,0x45,0x4c,
0xab,0xa2,0xb9,0xb0,0x8f,0x86,0x9d,0x94,0xe3,0xea,0xf1,0xf8,0xc7,0xce,0xd5,0xdc,
0x76,0x7f,0x64,0x6d,0x52,0x5b,0x40,0x49,0x3e,0x37,0x2c,0x25,0x1a,0x13,0x08,0x01,
0xe6,0xef,0xf4,0xfd,0xc2,0xcb,0xd0,0xd9,0xae,0xa7,0xbc,0xb5,0x8a,0x83,0x98,0x91,
0x4d,0x44,0x5f,0x56,0x69,0x60,0x7b,0x72,0x05,0x0c,0x17,0x1e,0x21,0x28,0x33,0x3a,
0xdd,0xd4,0xcf,0xc6,0xf9,0xf0,0xeb,0xe2,0x95,0x9c,0x87,0x8e,0xb1,0xb8,0xa3,0xaa,	
0xec,0xe5,0xfe,0xf7,0xc8,0xc1,0xda,0xd3,0xa4,0xad,0xb6,0xbf,0x80,0x89,0x92,0x9b,	
0x7c,0x75,0x6e,0x67,0x58,0x51,0x4a,0x43,0x34,0x3d,0x26,0x2f,0x10,0x19,0x02,0x0b,
0xd7,0xde,0xc5,0xcc,0xf3,0xfa,0xe1,0xe8,0x9f,0x96,0x8d,0x84,0xbb,0xb2,0xa9,0xa0,
0x47,0x4e,0x55,0x5c,0x63,0x6a,0x71,0x78,0x0f,0x06,0x1d,0x14,0x2b,0x22,0x39,0x30,
0x9a,0x93,0x88,0x81,0xbe,0xb7,0xac,0xa5,0xd2,0xdb,0xc0,0xc9,0xf6,0xff,0xe4,0xed,
0x0a,0x03,0x18,0x11,0x2e,0x27,0x3c,0x35,0x42,0x4b,0x50,0x59,0x66,0x6f,0x74,0x7d,	
0xa1,0xa8,0xb3,0xba,0x85,0x8c,0x97,0x9e,0xe9,0xe0,0xfb,0xf2,0xcd,0xc4,0xdf,0xd6,
0x31,0x38,0x23,0x2a,0x15,0x1c,0x07,0x0e,0x79,0x70,0x6b,0x62,0x5d,0x54,0x4f,0x46};

const Byte MulB[256] = {
0x00,0x0b,0x16,0x1d,0x2c,0x27,0x3a,0x31,0x58,0x53,0x4e,0x45,0x74,0x7f,0x62,0x69,
0xb0,0xbb,0xa6,0xad,0x9c,0x97,0x8a,0x81,0xe8,0xe3,0xfe,0xf5,0xc4,0xcf,0xd2,0xd9,
0x7b,0x70,0x6d,0x66,0x57,0x5c,0x41,0x4a,0x23,0x28,0x35,0x3e,0x0f,0x04,0x19,0x12,
0xcb,0xc0,0xdd,0xd6,0xe7,0xec,0xf1,0xfa,0x93,0x98,0x85,0x8e,0xbf,0xb4,0xa9,0xa2,
0xf6,0xfd,0xe0,0xeb,0xda,0xd1,0xcc,0xc7,0xae,0xa5,0xb8,0xb3,0x82,0x89,0x94,0x9f,
0x46,0x4d,0x50,0x5b,0x6a,0x61,0x7c,0x77,0x1e,0x15,0x08,0x03,0x32,0x39,0x24,0x2f,
0x8d,0x86,0x9b,0x90,0xa1,0xaa,0xb7,0xbc,0xd5,0xde,0xc3,0xc8,0xf9,0xf2,0xef,0xe4,
0x3d,0x36,0x2b,0x20,0x11,0x1a,0x07,0x0c,0x65,0x6e,0x73,0x78,0x49,0x42,0x5f,0x54,
0xf7,0xfc,0xe1,0xea,0xdb,0xd0,0xcd,0xc6,0xaf,0xa4,0xb9,0xb2,0x83,0x88,0x95,0x9e,
0x47,0x4c,0x51,0x5a,0x6b,0x60,0x7d,0x76,0x1f,0x14,0x09,0x02,0x33,0x38,0x25,0x2e,
0x8c,0x87,0x9a,0x91,0xa0,0xab,0xb6,0xbd,0xd4,0xdf,0xc2,0xc9,0xf8,0xf3,0xee,0xe5,
0x3c,0x37,0x2a,0x21,0x10,0x1b,0x06,0x0d,0x64,0x6f,0x72,0x79,0x48,0x43,0x5e,0x55,
0x01,0x0a,0x17,0x1c,0x2d,0x26,0x3b,0x30,0x59,0x52,0x4f,0x44,0x75,0x7e,0x63,0x68,
0xb1,0xba,0xa7,0xac,0x9d,0x96,0x8b,0x80,0xe9,0xe2,0xff,0xf4,0xc5,0xce,0xd3,0xd8,
0x7a,0x71,0x6c,0x67,0x56,0x5d,0x40,0x4b,0x22,0x29,0x34,0x3f,0x0e,0x05,0x18,0x13,
0xca,0xc1,0xdc,0xd7,0xe6,0xed,0xf0,0xfb,0x92,0x99,0x84,0x8f,0xbe,0xb5,0xa8,0xa3};

const Byte MulD[256] = {
0x00,0x0d,0x1a,0x17,0x34,0x39,0x2e,0x23,0x68,0x65,0x72,0x7f,0x5c,0x51,0x46,0x4b,
0xd0,0xdd,0xca,0xc7,0xe4,0xe9,0xfe,0xf3,0xb8,0xb5,0xa2,0xaf,0x8c,0x81,0x96,0x9b,
0xbb,0xb6,0xa1,0xac,0x8f,0x82,0x95,0x98,0xd3,0xde,0xc9,0xc4,0xe7,0xea,0xfd,0xf0,
0x6b,0x66,0x71,0x7c,0x5f,0x52,0x45,0x48,0x03,0x0e,0x19,0x14,0x37,0x3a,0x2d,0x20,
0x6d,0x60,0x77,0x7a,0x59,0x54,0x43,0x4e,0x05,0x08,0x1f,0x12,0x31,0x3c,0x2b,0x26,
0xbd,0xb0,0xa7,0xaa,0x89,0x84,0x93,0x9e,0xd5,0xd8,0xcf,0xc2,0xe1,0xec,0xfb,0xf6,
0xd6,0xdb,0xcc,0xc1,0xe2,0xef,0xf8,0xf5,0xbe,0xb3,0xa4,0xa9,0x8a,0x87,0x90,0x9d,
0x06,0x0b,0x1c,0x11,0x32,0x3f,0x28,0x25,0x6e,0x63,0x74,0x79,0x5a,0x57,0x40,0x4d,
0xda,0xd7,0xc0,0xcd,0xee,0xe3,0xf4,0xf9,0xb2,0xbf,0xa8,0xa5,0x86,0x8b,0x9c,0x91,
0x0a,0x07,0x10,0x1d,0x3e,0x33,0x24,0x29,0x62,0x6f,0x78,0x75,0x56,0x5b,0x4c,0x41,
0x61,0x6c,0x7b,0x76,0x55,0x58,0x4f,0x42,0x09,0x04,0x13,0x1e,0x3d,0x30,0x27,0x2a,
0xb1,0xbc,0xab,0xa6,0x85,0x88,0x9f,0x92,0xd9,0xd4,0xc3,0xce,0xed,0xe0,0xf7,0xfa,
0xb7,0xba,0xad,0xa0,0x83,0x8e,0x99,0x94,0xdf,0xd2,0xc5,0xc8,0xeb,0xe6,0xf1,0xfc,
0x67,0x6a,0x7d,0x70,0x53,0x5e,0x49,0x44,0x0f,0x02,0x15,0x18,0x3b,0x36,0x21,0x2c,
0x0c,0x01,0x16,0x1b,0x38,0x35,0x22,0x2f,0x64,0x69,0x7e,0x73,0x50,0x5d,0x4a,0x47,
0xdc,0xd1,0xc6,0xcb,0xe8,0xe5,0xf2,0xff,0xb4,0xb9,0xae,0xa3,0x80,0x8d,0x9a,0x97};

const Byte MulE[256] = {
0x00,0x0e,0x1c,0x12,0x38,0x36,0x24,0x2a,0x70,0x7e,0x6c,0x62,0x48,0x46,0x54,0x5a,
0xe0,0xee,0xfc,0xf2,0xd8,0xd6,0xc4,0xca,0x90,0x9e,0x8c,0x82,0xa8,0xa6,0xb4,0xba,
0xdb,0xd5,0xc7,0xc9,0xe3,0xed,0xff,0xf1,0xab,0xa5,0xb7,0xb9,0x93,0x9d,0x8f,0x81,
0x3b,0x35,0x27,0x29,0x03,0x0d,0x1f,0x11,0x4b,0x45,0x57,0x59,0x73,0x7d,0x6f,0x61,
0xad,0xa3,0xb1,0xbf,0x95,0x9b,0x89,0x87,0xdd,0xd3,0xc1,0xcf,0xe5,0xeb,0xf9,0xf7,
0x4d,0x43,0x51,0x5f,0x75,0x7b,0x69,0x67,0x3d,0x33,0x21,0x2f,0x05,0x0b,0x19,0x17,
0x76,0x78,0x6a,0x64,0x4e,0x40,0x52,0x5c,0x06,0x08,0x1a,0x14,0x3e,0x30,0x22,0x2c,
0x96,0x98,0x8a,0x84,0xae,0xa0,0xb2,0xbc,0xe6,0xe8,0xfa,0xf4,0xde,0xd0,0xc2,0xcc,
0x41,0x4f,0x5d,0x53,0x79,0x77,0x65,0x6b,0x31,0x3f,0x2d,0x23,0x09,0x07,0x15,0x1b,
0xa1,0xaf,0xbd,0xb3,0x99,0x97,0x85,0x8b,0xd1,0xdf,0xcd,0xc3,0xe9,0xe7,0xf5,0xfb,
0x9a,0x94,0x86,0x88,0xa2,0xac,0xbe,0xb0,0xea,0xe4,0xf6,0xf8,0xd2,0xdc,0xce,0xc0,
0x7a,0x74,0x66,0x68,0x42,0x4c,0x5e,0x50,0x0a,0x04,0x16,0x18,0x32,0x3c,0x2e,0x20,
0xec,0xe2,0xf0,0xfe,0xd4,0xda,0xc8,0xc6,0x9c,0x92,0x80,0x8e,0xa4,0xaa,0xb8,0xb6,
0x0c,0x02,0x10,0x1e,0x34,0x3a,0x28,0x26,0x7c,0x72,0x60,0x6e,0x44,0x4a,0x58,0x56,
0x37,0x39,0x2b,0x25,0x0f,0x01,0x13,0x1d,0x47,0x49,0x5b,0x55,0x7f,0x71,0x63,0x6d,
0xd7,0xd9,0xcb,0xc5,0xef,0xe1,0xf3,0xfd,0xa7,0xa9,0xbb,0xb5,0x9f,0x91,0x83,0x8d};

const Byte rcon[11] = {0x00,0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,0x1b,0x36};

const char dec2hex[16] = {'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};

void printhex(vector<Byte> input){
    int i =0;
    for(i=0;i<input.size();i++){
        Byte numtemp = input.at(i);
        Byte LHB = (numtemp&0xf0)>>4;
        Byte RHB = (numtemp&0x0f);
        cout<<dec2hex[LHB]<<dec2hex[RHB]<<'\n';
    }
}
vector<Byte> wrapper(array<Byte,16> input){
    vector<Byte> result;
    int i;
    for(i=0;i<16;i++){
        result.push_back(input[i]);
    }
    return result;
}
array<Byte,16> AddKey(array<Byte,16> Input, array<Byte,16> Key){
    array<Byte,16> result;
    Byte i;
    for(i=0;i<=15;i++){
        result[i] = Input[i]^Key[i];
    }
    return result;
}

array<Byte,16> KeyExpand(array<Byte,16> Key, Byte roundnum){
    Byte W0[4] = {Key[0],Key[1],Key[2],Key[3]}; //W as in "word" or a 32 bit unsigned number 
    Byte W1[4] = {Key[4],Key[5],Key[6],Key[7]};
    Byte W2[4] = {Key[8],Key[9],Key[10],Key[11]};
    Byte W3[4] = {Key[12],Key[13],Key[14],Key[15]};
    Byte WE[4] = {static_cast<Byte>(sBox[W3[1]]^rcon[roundnum]),static_cast<Byte>(sBox[W3[2]]),static_cast<Byte>(sBox[W3[3]]),static_cast<Byte>(sBox[W3[0]])}; //E because it's like a 3 but mirrored, this is because WE is a transformation of W3 with the g function
    Byte W4[4] = {static_cast<Byte>(W0[0]^WE[0]),static_cast<Byte>(W0[1]^WE[1]),static_cast<Byte>(W0[2]^WE[2]),static_cast<Byte>(W0[3]^WE[3])};
    Byte W5[4] = {static_cast<Byte>(W4[0]^W1[0]),static_cast<Byte>(W4[1]^W1[1]),static_cast<Byte>(W4[2]^W1[2]),static_cast<Byte>(W4[3]^W1[3])};
    Byte W6[4] = {static_cast<Byte>(W5[0]^W2[0]),static_cast<Byte>(W5[1]^W2[1]),static_cast<Byte>(W5[2]^W2[2]),static_cast<Byte>(W5[3]^W2[3])};
    Byte W7[4] = {static_cast<Byte>(W6[0]^W3[0]),static_cast<Byte>(W6[1]^W3[1]),static_cast<Byte>(W6[2]^W3[2]),static_cast<Byte>(W6[3]^W3[3])};
    array<Byte,16> result = {W4[0],W4[1],W4[2],W4[3],W5[0],W5[1],W5[2],W5[3],W6[0],W6[1],W6[2],W6[3],W7[0],W7[1],W7[2],W7[3]};
    return result;
}

array<Byte,16> SubByte(array<Byte,16> Input){
    array<Byte,16> result;
    Byte i;
    for(i=0;i<=15;i++){
        result[i] = sBox[Input[i]];
    }
    return result;
}

array<Byte,16> shiftrows(array<Byte,16> I){//changed Input for because the line is already long, having Input repeated wouldn't help xd
    array<Byte,16> Result = {I[0],I[5],I[10],I[15],I[4],I[9],I[14],I[3],I[8],I[13],I[2],I[7],I[12],I[1],I[6],I[11]};
    return Result;
}

array<Byte,4> MixColMain(array<Byte,4> Input){
    Byte d0 = Mul2[Input[0]]^Mul3[Input[1]]^Input[2]^Input[3];
    Byte d1 = Input[0]^Mul2[Input[1]]^Mul3[Input[2]]^Input[3];
    Byte d2 = Input[0]^Input[1]^Mul2[Input[2]]^Mul3[Input[3]];
    Byte d3 = Mul3[Input[0]]^Input[1]^Input[2]^Mul2[Input[3]];
    array<Byte,4> Result = {d0,d1,d2,d3};
    return Result;
}

array<Byte,16> MixCol(array<Byte,16> Input){
    array<Byte,4> T0 = MixColMain({Input[0],Input[1],Input[2],Input[3]});
    array<Byte,4> T1 = MixColMain({Input[4],Input[5],Input[6],Input[7]});
    array<Byte,4> T2 = MixColMain({Input[8],Input[9],Input[10],Input[11]});
    array<Byte,4> T3 = MixColMain({Input[12],Input[13],Input[14],Input[15]});
    array<Byte,16> Result = {T0[0],T0[1],T0[2],T0[3],T1[0],T1[1],T1[2],T1[3],T2[0],T2[1],T2[2],T2[3],T3[0],T3[1],T3[2],T3[3]};
    return Result;
}

array<Byte,16> AES128Enc(array<Byte,16> Input,array<Byte,16> Key){
    //key scheduling prepare
    array<Byte,16> k0 = Key;
    array<Byte,16> k1 = KeyExpand(k0, 1);
    array<Byte,16> k2 = KeyExpand(k1, 2);
    array<Byte,16> k3 = KeyExpand(k2, 3);
    array<Byte,16> k4 = KeyExpand(k3, 4);
    array<Byte,16> k5 = KeyExpand(k4, 5);
    array<Byte,16> k6 = KeyExpand(k5, 6);
    array<Byte,16> k7 = KeyExpand(k6, 7);
    array<Byte,16> k8 = KeyExpand(k7, 8);
    array<Byte,16> k9 = KeyExpand(k8, 9);
    array<Byte,16> ka = KeyExpand(k9,10);
    //round 0
    array<Byte,16> ARK0 = AddKey(Input,k0);
    //round 1
    array<Byte,16> SBB1 = SubByte(ARK0);
    array<Byte,16> SHR1 = shiftrows(SBB1);
    array<Byte,16> MXC1 = MixCol(SHR1);
    array<Byte,16> ARK1 = AddKey(MXC1,k1);
    //round 2
    array<Byte,16> SBB2 = SubByte(ARK1);
    array<Byte,16> SHR2 = shiftrows(SBB2);
    array<Byte,16> MXC2 = MixCol(SHR2);
    array<Byte,16> ARK2 = AddKey(MXC2,k2);
    //round 3
    array<Byte,16> SBB3 = SubByte(ARK2);
    array<Byte,16> SHR3 = shiftrows(SBB3);
    array<Byte,16> MXC3 = MixCol(SHR3);
    array<Byte,16> ARK3 = AddKey(MXC3,k3);
    //round 4
    array<Byte,16> SBB4 = SubByte(ARK3);
    array<Byte,16> SHR4 = shiftrows(SBB4);
    array<Byte,16> MXC4 = MixCol(SHR4);
    array<Byte,16> ARK4 = AddKey(MXC4,k4);
    //round 5
    array<Byte,16> SBB5 = SubByte(ARK4);
    array<Byte,16> SHR5 = shiftrows(SBB5);
    array<Byte,16> MXC5 = MixCol(SHR5);
    array<Byte,16> ARK5 = AddKey(MXC5,k5);
    //round 6
    array<Byte,16> SBB6 = SubByte(ARK5);
    array<Byte,16> SHR6 = shiftrows(SBB6);
    array<Byte,16> MXC6 = MixCol(SHR6);
    array<Byte,16> ARK6 = AddKey(MXC6,k6);
    //round 7
    array<Byte,16> SBB7 = SubByte(ARK6);
    array<Byte,16> SHR7 = shiftrows(SBB7);
    array<Byte,16> MXC7 = MixCol(SHR7);
    array<Byte,16> ARK7 = AddKey(MXC7,k7);
    //round 8
    array<Byte,16> SBB8 = SubByte(ARK7);
    array<Byte,16> SHR8 = shiftrows(SBB8);
    array<Byte,16> MXC8 = MixCol(SHR8);
    array<Byte,16> ARK8 = AddKey(MXC8,k8);
    //round 9
    array<Byte,16> SBB9 = SubByte(ARK8);
    array<Byte,16> SHR9 = shiftrows(SBB9);
    array<Byte,16> MXC9 = MixCol(SHR9);
    array<Byte,16> ARK9 = AddKey(MXC9,k9);
    //round 10
    array<Byte,16> SBBa = SubByte(ARK9);
    array<Byte,16> SHRa = shiftrows(SBBa);
    array<Byte,16> ARKa = AddKey(SHRa,ka);
    //return
    return ARKa;
}
// ok, now decryption XD
array<Byte,16> ISbox(array<Byte,16> Input){
    array<Byte,16> Result;
    Byte i;

    for(i=0;i<=15;i++){
        Result[i] = InvSbox[Input[i]];
    }
    return Result;
} 

array<Byte,16> InvShiftRows(array<Byte,16> I){
    array<Byte,16> result = {I[0],I[13],I[10],I[7],I[4],I[1],I[14],I[11],I[8],I[5],I[2],I[15],I[12],I[9],I[6],I[3]};
    return result;
}

array<Byte,4> InvMixColMain(array<Byte,4> input){
    Byte b0 = MulE[input[0]]^MulB[input[1]]^MulD[input[2]]^Mul9[input[3]];
    Byte b1 = Mul9[input[0]]^MulE[input[1]]^MulB[input[2]]^MulD[input[3]];
    Byte b2 = MulD[input[0]]^Mul9[input[1]]^MulE[input[2]]^MulB[input[3]];
    Byte b3 = MulB[input[0]]^MulD[input[1]]^Mul9[input[2]]^MulE[input[3]];
    array<Byte,4> result = {b0,b1,b2,b3};
    return result;
}

array<Byte,16> InvMixCol(array<Byte,16> I){
    array<Byte,4>  T0     = InvMixColMain({I[0], I[1], I[2], I[3]} );
    array<Byte,4>  T1     = InvMixColMain({I[4], I[5], I[6], I[7]} );
    array<Byte,4>  T2     = InvMixColMain({I[8], I[9], I[10],I[11]});
    array<Byte,4>  T3     = InvMixColMain({I[12],I[13],I[14],I[15]});
    array<Byte,16> result = {T0[0],T0[1],T0[2],T0[3],T1[0],T1[1],T1[2],T1[3],T2[0],T2[1],T2[2],T2[3],T3[0],T3[1],T3[2],T3[3]};
    return result;
}

array<Byte,16> AES128Dec(array<Byte,16> input, array<Byte,16> Key){ //low key, this was the most difficult function to write, don't ask me how XD
    //keys
    array<Byte,16> k0 = Key;
    array<Byte,16> k1 = KeyExpand(k0, 1);
    array<Byte,16> k2 = KeyExpand(k1, 2);
    array<Byte,16> k3 = KeyExpand(k2, 3);
    array<Byte,16> k4 = KeyExpand(k3, 4);
    array<Byte,16> k5 = KeyExpand(k4, 5);
    array<Byte,16> k6 = KeyExpand(k5, 6);
    array<Byte,16> k7 = KeyExpand(k6, 7);
    array<Byte,16> k8 = KeyExpand(k7, 8);
    array<Byte,16> k9 = KeyExpand(k8, 9);
    array<Byte,16> ka = KeyExpand(k9,10);
    //round 10
    array<Byte,16> ARKa  = AddKey(input,ka);
    array<Byte,16> ISHRa = InvShiftRows(ARKa);
    array<Byte,16> ISSBa = ISbox(ISHRa);
    //round 9
    array<Byte,16> ARK9  = AddKey(ISSBa,k9);
    array<Byte,16> IMXC9 = InvMixCol(ARK9);
    array<Byte,16> ISHR9 = InvShiftRows(IMXC9);
    array<Byte,16> ISSB9 = ISbox(ISHR9);
    //round 8
    array<Byte,16> ARK8  = AddKey(ISSB9,k8);
    array<Byte,16> IMXC8 = InvMixCol(ARK8);
    array<Byte,16> ISHR8 = InvShiftRows(IMXC8);
    array<Byte,16> ISSB8 = ISbox(ISHR8);
    //round 7
    array<Byte,16> ARK7  = AddKey(ISSB8,k7);
    array<Byte,16> IMXC7 = InvMixCol(ARK7);
    array<Byte,16> ISHR7 = InvShiftRows(IMXC7);
    array<Byte,16> ISSB7 = ISbox(ISHR7);
    //round 6
    array<Byte,16> ARK6  = AddKey(ISSB7,k6);
    array<Byte,16> IMXC6 = InvMixCol(ARK6);
    array<Byte,16> ISHR6 = InvShiftRows(IMXC6);
    array<Byte,16> ISSB6 = ISbox(ISHR6);
    //round 5
    array<Byte,16> ARK5  = AddKey(ISSB6,k5);
    array<Byte,16> IMXC5 = InvMixCol(ARK5);
    array<Byte,16> ISHR5 = InvShiftRows(IMXC5);
    array<Byte,16> ISSB5 = ISbox(ISHR5);
    //round 4
    array<Byte,16> ARK4  = AddKey(ISSB5,k4);
    array<Byte,16> IMXC4 = InvMixCol(ARK4);
    array<Byte,16> ISHR4 = InvShiftRows(IMXC4);
    array<Byte,16> ISSB4 = ISbox(ISHR4);
    //round 3
    array<Byte,16> ARK3  = AddKey(ISSB4,k3);
    array<Byte,16> IMXC3 = InvMixCol(ARK3);
    array<Byte,16> ISHR3 = InvShiftRows(IMXC3);
    array<Byte,16> ISSB3 = ISbox(ISHR3);
    //round 2
    array<Byte,16> ARK2  = AddKey(ISSB3,k2);
    array<Byte,16> IMXC2 = InvMixCol(ARK2);
    array<Byte,16> ISHR2 = InvShiftRows(IMXC2);
    array<Byte,16> ISSB2 = ISbox(ISHR2);
    //round 1
    array<Byte,16> ARK1  = AddKey(ISSB2,k1);
    array<Byte,16> IMXC1 = InvMixCol(ARK1);
    array<Byte,16> ISHR1 = InvShiftRows(IMXC1);
    array<Byte,16> ISSB1 = ISbox(ISHR1);
    //round 0
    array<Byte,16> ARK0  = AddKey(ISSB1,k0);
    return ARK0;
}

int main(){
    //-vvv- test encryption down here -vvv-
    //array<Byte,16> text = {0x0,0x0,0x1,0x1,0x3,0x3,0x7,0x7,0xf,0xf,0x1f,0x1f,0x3f,0x3f,0x7f,0x7f};
    //array<Byte,16> key  = {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0};
    //array<Byte,16> secret = AES128Enc(text,key);
    //array<Byte,16> desecret = AES128Dec(secret,key);
    //printhex(wrapper(desecret));
    return 0;
}